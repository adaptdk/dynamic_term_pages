<?php

/**
 * Implements hook_init().
 *
 * We call the globalredirect_init() hook if this page is not a dtp/ page.
 */
function dynamic_term_pages_init() {
  if (module_exists('globalredirect')) {
    $path = current_path();
    if (substr($path, 0, 4) != 'dtp/') {
      globalredirect_init();
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * We remove the init hook for globalredirect because it causes problems.
 */
function dynamic_term_pages_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'init') {
    if (isset($implementations['globalredirect'])) {
      unset($implementations['globalredirect']);
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory
 */
function dynamic_term_pages_ctools_plugin_directory($module, $plugin) {
  // we'll be nice and limit scandir() calls
  if (in_array($module, array('ctools', 'page_manager'))) {
    return "plugins/$plugin";
  }
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function dynamic_term_pages_taxonomy_term_insert($term) {
  dynamic_term_pages_pathauto_name_save($term);
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function dynamic_term_pages_taxonomy_term_update($term) {
  dynamic_term_pages_pathauto_name_save($term);
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function dynamic_term_pages_taxonomy_term_delete($term) {
  db_delete('dynamic_term_pathauto_name')->condition('tid', $term->tid)->execute();
}

/**
 * Save the pathauto cleaned term name so that we can use it to find our term id
 * Only save a cleaned name if pathauto is actually enabled.
 *
 * @param object $term
 *   The taxonomy term
 */
function dynamic_term_pages_pathauto_name_save($term) {
  // First check if the alias already exists for some other term. If yes, create
  // a new alias.
  if (dynamic_term_pages_name_exists($term)) {
    dynamic_term_pages_name_uniquify($term);
  }

  // We use tid as a unique key, so do a on duplicate key update
  db_merge('dynamic_term_pathauto_name')
    ->key(array('tid' => $term->tid))
    ->fields(array(
      'tid' => $term->tid,
      'pathauto_name' => dynamic_term_pages_cleanstring($term->name)
    ))->execute();
}

/**
 * Implements hook_taxonomy_term_load().
 */
function dynamic_term_pages_taxonomy_term_load($terms) {
  $result = db_select('dynamic_term_pathauto_name', 'dtp')->fields('dtp', array('tid', 'pathauto_name'))->condition('dtp.tid', array_keys($terms), 'IN')
    ->execute();
  foreach ($result as $record) {
    $terms[$record->tid]->pathauto_name = $record->pathauto_name;
  }
}

/**
 * Lookup pathauto term name in database
 * @param $name
 *  Dynamic alias. Term name run through dynamic_term_pages_cleanstring()
 *
 * @return $tid
 */
function dynamic_term_pages_pathauto_name_load($name) {
  $result = db_select('dynamic_term_pathauto_name', 'dtp')
    ->fields('dtp')
    ->condition('pathauto_name', $name)
    ->execute()
    ->fetchAssoc();

  if ($result) {
    return $result['tid'];
  }

  return FALSE;
}

/**
 * Check if a dynamic alias already exists for a different term.
 *
 * @param object $term
 *   Term object
 *
 * @return
 *   TRUE if an alias exists, FALSE if not.
 */
function dynamic_term_pages_name_exists($term) {
  $result = db_select('dynamic_term_pathauto_name', 'dtp')
    ->fields('dtp', array('tid'))
    ->condition('pathauto_name', dynamic_term_pages_cleanstring($term->name), '=')
    ->condition('tid', $term->tid, '!=')
    ->range(0, 1)
    ->execute()
    ->fetchField();

  return !empty($result);
}

/**
 * Create a unique alias.
 *
 * @param $term
 *   Taxonomy term object.
 */
function dynamic_term_pages_name_uniquify(&$term) {
  if (!dynamic_term_pages_name_exists($term)) {
    return;
  }

  $i = 0;
  do {
    $term->name = dynamic_term_pages_cleanstring($term->name) . '-' . $i;
    $i++;
  } while (dynamic_term_pages_name_exists($term));
}

/**
 * Create a clean alias out of a term name.
 */
function dynamic_term_pages_cleanstring($string) {
  include_once(drupal_get_path('module', 'pathauto') . '/pathauto.inc');

  return pathauto_cleanstring(check_plain($string));
}

/**
 * Implements hook_url_inbound_alter
 */
function dynamic_term_pages_url_inbound_alter(&$path, $original_path, $path_language) {
  if (variable_get('dynamic_term_pages_view_disabled', TRUE)) {
    return;
  }
  // Check if there are redirects.
  if (module_exists('redirect')) {
    $current_langcode = !empty($path_language) ? $path_language : $GLOBALS['language']->language;
    $current_query = drupal_get_query_parameters();
    if (redirect_load_by_source($original_path, $current_langcode, $current_query)) {
      return;
    }
  }

  $override = FALSE;

  // Check if path already exists, if it doesn't, check for a term in first level and redirect to our panel
  $exists = drupal_lookup_path('source', $original_path);

  // Only give access to urls with no alias that are not admin page, or if taxonomy term page override is enabled to taxonomy pages that are not edit pages
  $parts = explode('/', $path);
  $o_parts = explode('/', $original_path);

  if (!$exists && $parts[0] != 'admin') {
    $override = TRUE;
  }
  elseif (variable_get('dynamic_term_pages_override_taxonomy_term_page', FALSE) && $parts[0] == 'taxonomy' && !isset($parts[3])) {
    $override = TRUE;
  }

  // Handle front page.
  if (count($o_parts) == 1) {
    if (empty($o_parts[0])) {
      $override == FALSE;
    }
  }

  if ($override) {

    $override_type = variable_get('dynamic_term_pages_override_type', 0);

    module_load_include('inc', 'pathauto', 'pathauto');

    switch ($override_type) {
      case 1:
        $term_path = dynamic_term_pages_process_terms_hierarchical($o_parts);
        break;
      default:
        $term_path = dynamic_term_pages_process_terms_default($o_parts);
    }

    if (!$term_path) {
      // Exit if a term is not valid
      return;
    }

    // Redirect if path is not transliterated.
    if (substr($term_path, 1) != $original_path) {
      drupal_goto(substr($term_path, 1));
    }

    $path = 'dtp' . $term_path;
  }
}

/**
 * Implements hook_url_outbound_alter().
 *
 * Remove dtp/ from outbound url's, because we never want to see them.
 */
function dynamic_term_pages_url_outbound_alter(&$path, &$options, $original_path) {
  if ( substr($path, 0, 4) == 'dtp/' ) {
    $path = substr($path, 4);
  }
}

/**
 * Load terms using default method.
 *
 * @param array $o_parts
 * @return bool|string
 */
function dynamic_term_pages_process_terms_default($o_parts) {
  $term_path = '';

  $parents = _dynamic_term_pages_get_parents();
  $vids = array_keys($parents);

  foreach ($o_parts AS $slug) {
    $term = dynamic_term_pages_term_load($slug, $vids);
    if (!$term) {
      return FALSE;
    }
    $term_path .= '/' . pathauto_cleanstring($term->name);
  }

  return $term_path;
}

/**
 * Load terms using hierarchical method.
 *
 * @param array $o_parts
 * @return bool|string
 */
function dynamic_term_pages_process_terms_hierarchical($o_parts) {
  $parents = _dynamic_term_pages_get_parents();
  $vids = array_keys($parents);

  // Determine terms
  $term_path = '';
  foreach ($o_parts AS $slug) {
    $term = dynamic_term_pages_term_load($slug, $vids, $parents);
    if (!$term) {
      return FALSE;
    }

    $parents[$term->vid] = $term->tid;
    $term_path .= '/' . pathauto_cleanstring($term->name);
  }

  return $term_path;
}

/**
 * Get the parents array.
 *
 * @return array
 */
function _dynamic_term_pages_get_parents() {
  $parents = array();

  $enabled = variable_get('dynamic_term_pages_enabled_vocabularies', array());
  $enabled = array_keys($enabled);
  foreach ($enabled AS $voc) {
    $voc  = taxonomy_vocabulary_machine_name_load($voc);
    $parents[$voc->vid] = 0;
  }

  return $parents;
}

/**
 * Load dynamic term page term.
 *
 * We load using SQL because
 *
 * @param string $slug
 * @param array $vids
 * @param array $parents
 * @return stdClass|bool
 */
function dynamic_term_pages_term_load($slug, $vids=array(), $parents=array()) {

  // Static cache for terms.
  $terms = &drupal_static(__FUNCTION__, array());
  if (!empty($terms[$slug])) {
    return $terms[$slug];
  }

  $tid = dynamic_term_pages_pathauto_name_load($slug);

  if (!$tid) {

    $sql = "SELECT ttd.tid FROM {taxonomy_term_data} AS ttd
      LEFT JOIN {taxonomy_term_hierarchy} AS tth ON ttd.tid=tth.tid
      WHERE ttd.name = '" . check_plain($slug) . "'";

    if (!empty($parents)) {
      $sql .= " AND (";
      $parent_sql = array();
      foreach ($parents AS $vid => $tid) {
        $parent_sql[] = "(ttd.vid = " . $vid . " AND tth.parent = " . $tid . ")";
      }

      $sql .= implode(" OR ", $parent_sql);
      $sql .= ")";
    }
    elseif (!empty($vids)) {
      $sql .= " AND (";
      $vid_sql = array();
      foreach ($vids AS $vid) {
        $vid_sql[] = "(ttd.vid = " . $vid . ")";
      }

      $sql .= implode(" OR ", $vid_sql);
      $sql .= ")";
    }

    $query = db_query($sql);

    $result = $query->fetchAssoc();

    if (empty($result['tid'])) {
      return FALSE;
    }
    else {
      $result = taxonomy_term_load($result['tid']);
    }
  }
  else {
    $result = taxonomy_term_load($tid);
    if (!$result) {
      return FALSE;
    }

    // Handle parents so terms in hierarchy are not directly accessible.
    if (!empty($parents)) {
      $parent_tid = $parents[$result->vid];
      $term_parents = taxonomy_get_parents($tid);
      if ($parent_tid == 0) {
        if (!empty($term_parents)) {
          return FALSE;
        }
      }
      else {
        if (empty($term_parents[$parent_tid])) {
          return FALSE;
        }
      }
    }
  }

  // Set active term
  dynamic_term_pages_active_terms($result);

  // Store term in static cache with slug as key.
  $terms[$slug] = $result;

  return $result;
}

/**
 * Get the list of active terms within current request.
 *
 * @param [optional] $term
 * @return mixed
 */
function dynamic_term_pages_active_terms($term = NULL) {
  $terms = &drupal_static(__FUNCTION__, array());

  if (!empty($term)) {
    $terms[$term->tid] = $term;
  }

  return $terms;
}
